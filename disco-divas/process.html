<!DOCTYPE HTML>
<!--
	Helios by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
    <title>Disco Divas</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="assets/css/main.css" />
    <noscript>
        <link rel="stylesheet" href="assets/css/noscript.css" />
    </noscript>
</head>

<body class="homepage is-preload">
    <div id="page-wrapper">


        <!-- Nav -->
        <nav id="nav">
            <ul>
                <li><a href="index.html">Home</a></li>
                <li>
                    <a href="#">Subsystems</a>
                    <ul>
                        <li><a href="mech.html"">Mechanical</a></li>
                                    <li><a href=" elec.html">Electrical</a></li>
                        <li><a href="firm.html">Firmware</a></li>
                        <li><a href="soft.html">Software</a></li>
                    </ul>
                </li>
                <li><a href="process.html">Process</a></li>
                <li><a href="budget.html">Budget</a></li>
                <li><a href="team.html">The Team</a></li>
            </ul>
        </nav>

    </div>

    <!-- Banner -->
    <section id="banner">
        <header>
            <!-- <h2><strong>Electrical and Firmware Design</strong></h2> -->

        </header>
    </section>

    <!-- Main -->
    <div class="wrapper style2">

        <article id="main" class="container special">
            <a href="#" class="image featured"><img src="images/final_1.jpg" alt="" /></a>
            <header>
                <h2><a href="#">Our Process</a></h2>

            </header>

    <p>
    We completed this project in three two-week long sprints. Here’s what we did in each one!
    </p>
    <p>
        <br>
    </p>
    <head>
        <style>
        * {
          box-sizing: border-box;
        }
        
        .column {
          float: left;
          width: 33.33%;
          padding: 5px;
        }
        
        /* Clearfix (clear floats) */
        .row::after {
          content: "";
          clear: both;
          display: table;
        }
        </style>
        </head>
        <body>

        <div class="row">
          <div class="column">
            <img src="images/final_4.jpg" alt="Snow" style="width:100%">
          </div>
          <div class="column">
            <img src="images/drawing_1.JPG" alt="Mountains" style="width:89%">
          </div>
          <div class="column">
            <img src="images/final_2.JPG" alt="Forest" style="width:100%">
          </div>
        </div>
        <p>
        </p>

        </body>
        </html>

    <p id="sprint1">
    <h3><strong>Sprint 1</strong> </h3>
    </p>
    <p>
    <strong>Sprint 1 Deliverables:</strong>
    </p>
    <p>
    Mechanical: 
    </p>
    <ul>
    
    <li>Create a spinning disk, an arm that holds one pen (stationary), and a box to house all components.
    
    <li>Start thinking about & designing pen-moving linear mechanism
    </li>
    </ul>
    <p>
    Software: 
    </p>
    <ul>
    
    <li>Figure out libraries that deal with audio processing. 
    
    <li>Create graphs of frequencies or some other breakdown of music
    </li>
    </ul>
    <p>
    Electrical/Firmware:
    </p>
    <ul>
    
    <li>Spin the turntable
    </li>
    </ul>
    <p>
    <strong>Mechanical Design:</strong>
    </p>
    <p>
    For our first sprint, our main objective was rotating the turntable. To do this, we laser cut a small gear to put on the motor shaft. We laser cut teeth onto the edges of the disk so it could mesh with the small gear, creating a 12:1 gear ratio. This large gear ratio along with a slow spinning DC motor allowed us to spin the disk sufficiently slowly that it would complete only one rotation over the length of one song. 
    </p>
    <p>
    <p>
        <a href="#" class="image featured"><img src="images/S1-CAD.png" alt="" style="width:45%"/></a>
        <figcaption>Fig. Initial CAD</figcaption>

    </p>
    </p>
    <p>
    We created the structure for our first prototype out of ⅛” hardboard and added a structure to hold a pen. 
    </p>

    <p>
    <figure>
        <img src="images/S1-Image.png" alt="" style="width:52%"/>
        <figcaption>Fig. Sprint 1 prototype</figcaption>
    </figure>
    </p>


    <p>
    <strong>Electrical/Firmware Design:</strong>
    </p>
    <p>
        In terms of integrated electronics, the first sprint was pretty simple. I hooked up a spare DC motor to the prototype and ran it at different speeds with serial commands. In the background I was researching stepper motors and motor control for the next sprint.
    </p>
    <p>
    <strong>Software Design:</strong>
    </p>
    <p>
    Going into the first sprint, we had a lot of uncertainty about how difficult the kind of audio analysis we were trying to do would be. This sprint involved a lot of researching and trying out different audio processing libraries. The goal was to start by breaking the song up into different frequencies. The visuals below, called chromagraphs, were generated by using the library Librosa. At the end of the project, we only ended up using Librosa to load the song, which was not strictly necessary (so we didn’t end up using many of the features of the library at the end of the day).
    </p>
    <p>
        <figure>
            <img src="images/chromagraph_1.png" alt="">
            <img src="images/chromagraph_2.png" alt="">
            <figcaption>Fig. chromagraphs</figcaption>
        </figure>
    </p>
    <p>
        <h3><strong>Sprint 2</strong> </h3>
    </p>
    <p>
    <strong>Sprint 2 Goals:</strong>
    </p>
    <p>
    Electrical/firmware:
    </p>
    <ul>
    
    <li>Spin the stepper motors that move the pens back and forth while the disk is spinning
    </li>
    </ul>
    <p>
    Software: 
    </p>
    <ul>
    
    <li>Create customized frequency-splitting workflow and visualization
    </li>
    </ul>
    <p>
    Mechanical: 
    </p>
    <ul>
    
    <li>Design and build a system to move the pens back and forth as the disk spins
    </li>
    </ul>
    <p>
    <strong>Mechanical Design:</strong>
    </p>

    <p>
        Developing a mechanism to move the pens back and forth was our main mechanical objective for this sprint. After investigating many linear motion mechanisms, we decided to use a lead screw because it would be easy to control, precise, sturdy, and relatively inexpensive. 
    </p>
    <p>
        <figure>
            <img src="images/lead_screws.png" alt="" style="width:25%"/>
            <figcaption>Fig. linear pen mechanism</figcaption>
        </figure>
    </p>

    <p>

    </p>
    <p>
        When designing the linear motion mechanism, we hoped to use as few components as we could and make our system as compact as possible. We connected each of our three Nema 17 Stepper Motors directly to the lead screw using a shaft coupler and stacked the three identical mechanisms vertically. This also allowed us to keep the three pens aligned along the radius of the circle. 
    </p>
   
    <p>
        <figure>
            <img src="images/S2-CAD.png" alt="" style="width:50%"/>
            <figcaption>Fig. CAD for sprint 2 prototype</figcaption>
        </figure>
    </p>
    <p>
        To mount the plate holding the ends of the lead screws, we chose to add a bar across the top of the disk. This created a secure attachment, while still allowing space to slide pieces of paper in and out of our machine. Finally, we replace our small motor gear with a COTS part, and recut our disk out of ¼” red acrylic with smaller teeth to mesh with it, helping our disk to spin more smoothly. 

    </p>
    

    <p>
        <figure>
            <img src="images/S2_prototype.jpg" alt="" style="width:70%"/>
            <figcaption>Fig. sprint 2 prototype</figcaption>
        </figure>
    </p>
    
    <p>
        <strong>Electrical/Firmware Design:</strong>
    </p>
 

<p>The second sprint is when electronics were really kicked into action. Parts were ordered at the beginning of the sprint and assembled with some basic firmware by the end. </p>
<p><a href="#"><img src="images/sprint2schematic.png" alt=""></a></p>
<p>It took some time to figure out how to set up the stepper motor drivers correctly because I couldn&#39;t find any 10 μF capacitors in the Olin stock room and had to order more. It was also quite tricky to set the current limit correctly with a screw driver since I didn&#39;t initially have an alligator clip. These are definitely things I&#39;d suggest confirming you have before staring if you try to recreate something similar. </p>
<p>Once the motor drivers were wired cleanly I attached one of the motors and tested it with an example script from the default Arduino stepper library. This worked great until I tried running both the DC and stepper motors at the same time. The stepper motor would jump around uncontrollably in both directions. Initially I though our power source didn&#39;t have enough current for both motors but after testing and experimenting for a few hours I attempted controlling each with completely separate circuits and power supplies only to experience the same issue. At this point I realized that the issue was actually the DC motor&#39;s electromagnetic field and that my stepper signal wires needed to be twisted. Twisting all of the wires and adding small capacitors across the circuit eventually fixed this issue.</p>
<p>Once this was settled, I wrote an Arduino sketch to control the DC and stepper motor over serial and a short python script on the Raspberry Pi to send commands with dummy data. While these short steps always take longer than expected to tune perfectly, by the end of the sprint I had made good progress towards the final MVP, especially in terms of electronics.</p>

   
    <p>
    <strong>Software Design:</strong>
    </p>
    <p>
    The goal with this sprint was to get to an MVP level visual, where the frequencies were split up and represented with their changes over time.
    </p>


    <p>
    One of the first steps was getting the frequency data over the course of the song. To do this, we ended up using a Fast Fourier transform to separate the frequencies, rather than using an audio processing library, because that ended up being more complicated.
    </p>
    <p>
        <figure>
            <img src="images/all_freq_data.png" alt="">
            <figcaption>Fig. "all_freq_data" Dataframe</figcaption>
        </figure>
    </p>
    <p>
    We ended up with a dataframe with frequencies in the rows and time samples (in ms) in each column. The value in each cell corresponds to the volume of that signal. A few key observations are that the values go from 0 to -100, where 0 is the loudest and -100 is no audio signal. 
    </p>
    <p>
    The next step was to split it into three buckets, bass, mid, and treble. However, we found that the borderline between those categories was different with each song, based on how many frequencies comprised it. We ended up using a logarithmic scale to split the buckets. We then used a weighted average (that took a bit of tuning) to come up with the volume over time of each bucket. Visualized in a graph, it looks like this: 
    </p>
    <p>
        <figure>
            <img src="images/frequency_plot_1.png" alt="">
            <figcaption>Fig. frequency plot over time</figcaption>
        </figure>
    </p>
    <p>
    Unfortunately, all three buckets looked pretty similar. We also tried a percussion/harmonic split, which was a bit better. This is the same song but with the percussion removed: 
    </p>
    <p>
        <figure>
            <img src="images/frequency_plot_2.png" alt="">
            <figcaption>Fig. frequency plot over time without percussion</figcaption>
        </figure>
    </p>
    <p>
    However, that’s not really what we wanted either. We decided to leave the percussion in and see what it looked like in the circular representation we wanted. 
    </p>
    <p>
        <figure>
            <img src="images/circular_visual_1.png" alt="" style="width:25%">
            <img src="images/circular_visual_2.png" alt="" style="width:26%">
            <figcaption>Fig. first iteration of circular visual</figcaption>
        </figure>
    </p>
    <p>
    They’re pretty basic and not that interesting to look at, but they captured the information we wanted to include, so they were a good start. 
    </p>
    <p>
    We then worked on creating a CSV to hold the positions we wanted each motor to be at at a given time, so that we could package the data from the visualizations into something that firmware could use. The CSV ended up looking something like this:
    </p>
    <p>
        <figure>
            <img src="images/position_csv.png" alt="" style="width:20%">
            <figcaption>Fig. position CSV to pass to firmware</figcaption>
        </figure>
    </p>
    <p>
    We were able to pass that to firmware for testing.
    </p>
    <p>
    <h3><strong>Sprint 3</strong> </h3>
    </p>
    <p>
    <strong>Sprint 3 Goals:</strong>
    </p>
    <p>
    Hit our MVP - creating a record player-like machine, where one rotation of the machine corresponds to the length of the song. While the machine rotates, 3 pens will shift back and forth to draw the intensity of various frequency bands. The resulting image is 3 concentric “circles”, with oscillations varying in intensity.
    </p>
    <p>
    Mechanical: 
    </p>
    <ul>
    
    <li>Remake final structure out of stronger materials
    
    <li>Small optimizations and redesigns based on testing
    </li>
    </ul>
    <p>
    Electrical/Firmware:
    </p>
    <ul>
    
    <li>Move all motors to draw <em>something</em> from the music
    
    <li>Fully tie together mechanical and software; debug calibration issues
    </li>
    </ul>
    <p>
    Software: 
    </p>
    <ul>
    
    <li>Continue making the visualization more meaningful
    
    <li>Scaling, adding in oscillations, trying out different songs and making small optimizations
    </li>
    </ul>
    <p>
    <strong>Mechanical Design:</strong>
    </p>
    <p>
        <figure>
            <img src="images/full_box_1.jpg" alt="" style="width:40%"/>
            <img src="images/pens_close_up.jpg" alt="" style="width:28%"/>
            <figcaption>Fig. sprint 3 prototype-full system</figcaption>
        </figure>
    </p>
    <p>
    The mechanical design changes in sprint 3 included remaking the pen mounts to make them more sturdy, remaking the box out of ¼” plywood, and and 
    </p>

    <p>
        <strong>Electrical/Firmware Design:</strong>
    </p>

    <p>I had the DC motor and one stepper motor working great from the last sprint. Initially I assumed that the code for the rest of the stepper motors would be nearly identical to what I had put together for sprint 2 but what I didn&#39;t realize at the time was that the default Arduino stepper library runs steppers with blocking functions, meaning that the entire program would essentially stop until a stepper motor reached its destination. This was clearly not going to work as we needed to run three steppers at the same time, separately, while also processing serial commands. </p>
    <p>After research and experimenting with various solutions, I discovered the AccelStepper library, which, although more complicated and less documented than the default library, uses non-blocking functions to control stepper motors. This is explained in more detail on the Firmware Design page. </p>
    <p>Once I figured out how to use the library, I rewrote the entire Arduino sketch and then did a significant amount of testing to determine parameters such as the stepper motor maximum speed. Once everything was working as expected and mounted on the final structure, I worked with software to determine the relationship between stepper steps and the linear movement of the lead screw and the speed of the disk relative to the speed setting on the DC motor.</p>
    


    <p>
    <strong>Software Design</strong>
    </p>
    <p>
    One big goal was to continue making the visualizations better. We decided to add in oscillations to capture the feel of music a bit more and ended up with something like this:
    </p>
    <p>
        <figure>
            <img src="images/oscillations_1.png" alt="">
            <figcaption>Fig. first visualization with oscillations</figcaption>
        </figure>
    </p>
    <p>
    This is much more dynamic, and we liked it a lot better. One important learning was that the sampling rate matters a lot, because it affects the density of the points. For example, the same song at different sampling rates:
    </p>
    <p>
        <figure>
            <img src="images/oscillations_dense.png" alt="" style="width:30%">
            <img src="images/oscillations_2.png" alt="" style="width:30%">
            <figcaption>Fig. the same song plotted at different sampling rates</figcaption>
        </figure>
    </p>
    <p>
    Clearly, the one on the right is much more realistic for our physical system to draw.
    </p>
    <p>
    We then tried putting in some different songs with different sounds, and got the following results (along with the previous two).
    </p>
    <p>
        <figure>
            <img src="images/oscillations_3.png" alt="" style="width:30%">
            <img src="images/oscillations_4.png" alt="" style="width:30%">
            <figcaption>Fig. some more songs plotted with oscillations</figcaption>
        </figure>
    </p>
    <p>
    Unfortunately, all the songs ended up looking pretty similar. We tried a couple things, like scaling things up to take more of the circle, but it didn’t change the visualizations too much. We also noticed that all four songs had a weird spike at the beginning/end, which we thought should not be the case. 
    </p>
    


    <p>
        <strong>Mechanical Design:</strong>
    </p>

    <p>During the final push, we continued to fix small mechanical issues, like the pens&#39; tension against the paper. We also added paint to the box!</p>
    <p><img src="images/final_2.JPG" alt="" style="width:80%"></p>

    <p>
        <strong>Electrical/Firmware Design:</strong>
    </p>
    <p>Everything left:</p>
    <ul>
    <li>Mount electronics</li>
    <li>Resolve stepper motor lockup</li>
    <li>Add screen</li>
    </ul>
    <p>Immediately after the sprint 3 review, I got to work mounting all the electronics securely to the shelf that the mechanical team had put together. Although time consuming, this was very valuable as it eliminated the risk of loose wires.</p>
    <p>An issue that had been discovered by the software team in the previous sprint was that sometimes stepper motors would lock up and loudly buzz when sent a new command before the motor had reached its target destination. To fix this I added the <code>next_taget</code> array described on the Firmware Design page to add a buffer of one command. This worked smoothly most of the time with only rare occurrences of the motor stalling when traveling thousands of steps. This logic was continuously tweaked for a few days, sometimes interrupting and overriding motor movement and sometimes waiting until the previous target was reached before starting again. We ultimately decided on the latter. If I had more time to work on this project I would have further optimized this code and tried adding different buffers for situations where several commands are being sent in the time it takes for the motor to move to a target position, as we observed happening on the final product, resulting in occasional skipped instructions. If that didn&#39;t resolve the issue I&#39;d probably implement logic to check that the next instruction has the inverse instruction of the previous instruction to avoid cases where the rising edge of two waves are stacked and shift a band up*. Overall, considering the limits of stepper motor/lead screw speed, we should have either switched to belts to draw back the song in real time or slowed down the rotation of the disk (and process as a whole) to allow for the steppers get get where they need to be before sending more commands.</p>
    <p>*at the end of the project we weren&#39;t sure if this was a firmware, software, or mechanical issue, but continued optimizations in each could have improved the outcome.</p>
    


    <p>
        <strong>Software Design:</strong>
    </p>
    
    <p>
    After the 3rd sprint, we had a little more time to improve the visualization. We got rid of the spike at the beginning by trimming the quiet parts of the song at the beginning and the end. We also pulled the -100 values up to -80 or so. Those two things were throwing off the scaling, because they were throwing off the average volumes. They made the visualizations a lot better. We also tried a classical song (because while all the songs we tried had different sounds, they’re all a little more similar to each other than they are to the classical song).
    </p>
    <p>
        <figure>
            <img src="images/osc_little_night.png" alt="" style="width:30%">
            <img src="images/osc_love_story.png" alt="" style="width:30%">
            <img src="images/osc_miz_biz.png" alt="" style="width:30%">
            <figcaption>Fig. some of our final visualizations</figcaption>
        </figure>
    </p>
            <!-- everything else in main text goes here-->
        </article>

    </div>

    <!-- Footer -->
    <div id="footer">
        <div class="container">

            <div class="row">
                <div class="col-12">

                    <!-- Copyright -->
                    <div class="copyright">
                        <ul class="menu">
                            <li></li>
                            <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
                        </ul>
                    </div>

                </div>

            </div>
        </div>
    </div>

    </div>

    <!-- Scripts -->
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery.dropotron.min.js"></script>
    <script src="assets/js/jquery.scrolly.min.js"></script>
    <script src="assets/js/jquery.scrollex.min.js"></script>
    <script src="assets/js/browser.min.js"></script>
    <script src="assets/js/breakpoints.min.js"></script>
    <script src="assets/js/util.js"></script>
    <script src="assets/js/main.js"></script>

</body>

</html>